package tlc

import (
	"bytes"
	"fmt"
	"go/format"
	"log"

	"github.com/andreyvit/telegramapi/tl/tlschema"
)

type Options struct {
	PackageName string
	SkipPrelude bool
}

type originInfo struct {
	Name   string
	GoName string
	Combs  []uint32
}

func GenerateGoCode(sch *tlschema.Schema, options Options) string {
	rm := NewReprMapper(sch)
	rm.Finalize()

	buf := new(bytes.Buffer)

	if !options.SkipPrelude {
		// recognized by GitHub's Linguist and matches Rob Pike's proposal at https://github.com/golang/go/issues/13560
		buf.WriteString("// Code generated by tlc (github.com/andreyvit/telegramapi/tl/cmd/tlc). DO NOT EDIT.\n")
		buf.WriteString("package ")
		buf.WriteString(options.PackageName)
		buf.WriteString("\n")

		var imports []string
		imports = append(imports, "github.com/andreyvit/telegramapi/tl")
		imports = append(imports, rm.GoImports()...)
		importsSet := make(map[string]bool)

		buf.WriteString("\n")
		buf.WriteString("import(\n")
		for _, s := range imports {
			if !importsSet[s] {
				importsSet[s] = true
				buf.WriteString("\t\"" + s + "\"\n")
			}
		}
		buf.WriteString(")\n")

		idx := 0
		prevOrigin := ""
		for _, comb := range sch.Combs() {
			if comb.IsInternal {
				continue
			}

			if comb.Origin != prevOrigin {
				if idx > 0 {
					buf.WriteString(")\n")
				}
				buf.WriteString("\n")
				buf.WriteString("// from ")
				buf.WriteString(comb.Origin)
				buf.WriteString("\n")
				buf.WriteString("const (\n")
				prevOrigin = comb.Origin
				idx = 0
			}
			// if comb.Tag == 0 {
			// 	continue
			// }
			buf.WriteString("\t")
			buf.WriteString(IDConstName(comb))
			if idx == 0 {
				buf.WriteString(" uint32")
			}
			buf.WriteString(" = ")
			buf.WriteString(fmt.Sprintf("0x%08x", comb.Tag))
			buf.WriteString("\n")
			idx++
		}
		buf.WriteString(")\n")

		var origins []*originInfo
		var originMap = make(map[string]*originInfo)

		for _, comb := range sch.Combs() {
			if comb.IsInternal {
				continue
			}
			if comb.Tag == 0 {
				continue
			}
			orig := originMap[comb.Origin]
			if orig == nil {
				orig = &originInfo{Name: comb.Origin, GoName: "SchemaOrigin" + tlschema.ToGoName(comb.Origin)}
				originMap[comb.Origin] = orig
				origins = append(origins, orig)
			}
			orig.Combs = append(orig.Combs, comb.Tag)
		}

		buf.WriteString("\n")
		buf.WriteString("type SchemaOrigin int\n")
		buf.WriteString("\n")
		buf.WriteString("const (\n")
		for i, orig := range origins {
			buf.WriteString("\t")
			buf.WriteString(orig.GoName)
			if i == 0 {
				buf.WriteString(" SchemaOrigin = 1 + iota")
			}
			buf.WriteString("\n")
		}
		buf.WriteString(")\n")

		buf.WriteString("\n")
		buf.WriteString("var combOrigins = map[uint32]SchemaOrigin{\n")
		for _, comb := range sch.Combs() {
			if comb.IsInternal {
				continue
			}
			if comb.Tag == 0 {
				continue
			}
			orig := originMap[comb.Origin]
			buf.WriteString("\t")
			buf.WriteString(IDConstName(comb))
			buf.WriteString(": ")
			buf.WriteString(orig.GoName)
			buf.WriteString(",\n")
		}
		buf.WriteString("}\n")
	}

	rm.AppendGoDefs(buf, CodeGenOptions{
		SkipUtil:     options.SkipPrelude,
		SkipSwitch:   options.SkipPrelude,
		SkipComments: options.SkipPrelude,
	})

	if false {
		log.Printf("All type IDs:")
		for i, s := range rm.AllTypeIDs() {
			log.Printf("%03d. %s", i, s)
		}
	}

	src := buf.Bytes()
	fmt, err := format.Source(src)
	if err != nil {
		log.Println(string(src))
		panic(err)
	}
	return string(fmt)
}
